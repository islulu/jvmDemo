#jvm#
- Java内存结构
    HotSpotVM：(目前使用范围最广的Java虚拟机)
    运行时数据区域：
        线程共享
            [Java堆]：使用new的对象、定义数组(垃圾回收机制算法 jvm参数调优 内存溢出和内存泄漏)
                java虚拟机所管理的内存中最大的一块
                唯一目的就是【存放对象实例】，所有的对象实例以及数组都要在堆上分配
                垃圾收集器管理的主要区域，因此也被称为“GC堆”
                从内存回收角度来看，java堆可分为新生代和老生代
                从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区
                根据Java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中
                如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

            [方法区]：类的信息、常量、静态变量(永久区 full GC)
                用于存储【已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据】
                别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常

                [运行时常量池]：
                    Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，
                    用于【存放编译期生成的各种字面量和符号引用】，这部分内容将在加载后进入方法区的运行时常量池中存放

        线程私有
            [Java虚拟机栈]：基本数据类型、局部变量(每个线程独立栈)
                生命周期和线程相同，Java方法执行的内存模型
                每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储：【局部变量表、操作数栈、动态链接、方法出口等信息】

                局部变量表
                    存放了【编译期可知的各种基本数据类型(8个基本数据类型)、对象引用(地址指针)、returnAddress类型】
                    所需的内存空间在编译期间完成分配。在运行期间不会改变局部变量表的大小
                    两种异常状态：
                        如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常
                        如果虚拟机栈可以动态扩展，在扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常

            [本地方法栈]：Java语言调用外部语言(C语言)方法使用native(CAS)
                本地方法栈与虚拟机栈所发挥作用非常相似，区别是虚拟机栈为虚拟机执行Java方法(即字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务。本地方法栈也是抛出两个异常

            [程序计数器]：
                程序计数器是一块较小的内存空间，是【当前线程所执行的字节码的行号指示器】
                由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令

                为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存
                程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域

        [直接内存]：
            不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。
            这部分区域被频繁使用，可能导致OutOfMemoryError异常
            NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，
            可使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作

    执行引擎：
        虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般先进行编译成机器码后执行

- Java内存模型
    线程栈（ThreadLocal）
        包含这个线程的方法执行到哪一个点了这些信息
        包括了每个方法执行时的local 变量
            （所有的方法也都存储在线程栈上，一个线程可以只能访问自己的线程栈。
              每个线程自己创建的本地本地变量对其他线程是不可见的，也就是私有的，
              即使两个线程调用的是同一个方法，每个线程会分别保存一份本地变量，各自属于各自的线程栈）

        所有基本类型的local变量，全都被存储在线程栈里
    堆中存储着java程序中new出来的对象，存储在堆上的对象可以被所有的线程通过引用来访问
        如果两个线程同时调用同一个对象的一个方法，他们就会都拥有这个对象的成员变量，但是每一个线程会享有自己私有的本地变量。

    静态的类变量一般也存储在堆上，根据类的定义。



- 垃圾回收机制
    不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收。
    垃圾收集器在一个Java程序中的执行是自动的，不能强制执行。可通过调用System.gc方法来"建议"执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。

    finalize方法作用：
        在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。
        是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。
        在Object类中定义的(所有的类都继承了它)子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。
        finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。

    新生代与老年代:
        堆被划分成两个不同的区域：新生代(Young)、老年代(Old)。新生代(Young)又被划分为三个区域：Eden、From Survivor、To Survivor。
        划分目的：使JVM能够更好的管理堆内存中的对象，包括内存的分配以及回收。
        * 根据垃圾回收机制的不同，Java堆有可能拥有不同的结构

        新生代：存放新生的对象或者年龄不大的对象 age<15 ；老年代：存放老年对象。
        绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，
        之后每经过一次新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。

    如何判断对象是否存活:
        引用计数法:(不选择使用
            给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减１.
            任何时刻计数器值为０的对象就是不可能再被使用的。
            为什么主流的Java虚拟机里面都没有选用这种算法呢？原因是它很难解决对象之间相互循环引用的问题。

        根搜索算法:
            通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，
            当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

            如何选取GCRoots对象：
                (1)虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
                (2)方法区中的类静态属性引用的对象。
                (3)方法区中常量引用的对象。
                (4)本地方法栈中JNI(Native方法)引用的对象。

    垃圾回收机制策略:
        标记清除算法:（老年代）
            该算法有两个阶段:
                1.标记阶段：找到所有可访问的对象，做个标记
                2.清除阶段：遍历堆，把未被标记的对象回收
            应用场景:
                应用于老年代,因为老年代的对象生命周期比较长
            优缺点:
                1. 优点
                    可以解决循环引用的问题
                    必要时才回收(内存不足时)
                2. 缺点：
                    回收时，应用需要挂起，也就是stop the world。
                    标记和清除的效率不高，尤其是要扫描的对象比较多的时候
                    会造成内存碎片(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)

        复制算法:(新生代，去碎片化)
            如果jvm使用了coping算法，一开始就会将可用内存分为两块from域和to域，每次只是使用from域，to域则空闲着。
            当from域内存不够了，开始执行GC操作，这个时候，会把from域存活的对象拷贝到to域,然后直接把from域进行内存清理。

            1.当Eden区满的时候,会触发第一次young gc,把还活着的对象拷贝到Survivor From区；
              当Eden区再次触发young gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,
              经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。
            2.当后续Eden又发生young gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。
            3.可见部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代

            注意: 万一存活对象数量比较多，那么To域的内存可能不够存放，这个时候会借助老年代的空间。

            应用场景:
                使用在新生代中,因为新生代中的对象一般都是朝生夕死的,存活对象的数量并不多,coping算法进行拷贝时效率比较高。
            优缺点:
                优点:在存活对象不多的情况下，性能高，能解决内存碎片和java垃圾回收算法之-标记清除 中导致的引用更新问题。
                缺点:1.会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；2.如果存活对象的数量比较大，coping的性能会变得很差。

        标记整理算法:(老年代，去碎片化)
            标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化

            * 将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

            任意顺序:不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象
            线性顺序:考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块
            滑动顺序:按照对象原来在堆中的顺序滑动到堆的一端

            优缺点:
                优点:解决内存碎片问题
                缺点:压缩阶段，由于移动了可用对象，需要去更新引用

            MinorGC和FullGC区别:
                (新生代GC)MinorGC：
                    Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。
                (老年代GC)MajorGC/FullGC：
                    出现了MajorGC经常会伴随至少一次的MinorGC
                    (但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程)
                MajorGC的速度一般会比MinorGC慢10倍以上。
                -----------------------------------
                MinorGC触发机制：
                    当年轻代(Eden代)满时就会触发MinorGC，Survivor满不会引发GC
                FullGC触发机制：
                    当年老代满时会引发FullGC，FullGC将会同时回收年轻代、年老代，
                    当永久代满时也会引发FullGC，会导致Class、Method元信息的卸载其中
                    (JVM的永久代中会发生垃圾回收么？
                        垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。

                    Full GC 原因：
                        System.gc()方法的调用：
                            很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数
                        老年代代空间不足
                            新生代对象转入及创建为大对象、大数组时会出现不足的现象，当执行Full GC后空间仍然不足

                            -》尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
                        永生区空间不足
                            存放class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时可能会被占满
                            在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了 就报错了

                            -》采用CMS GC
                        CMS GC时出现promotion failed和concurrent mode failure
                            promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的
                            concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的

                            -》增大survivor space、老年代空间或调低触发并发GC的比率
                        统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间
                            Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。

                            -》当新生代采用PS GC时，PS GC是在Minor GC后也会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。
                        堆中分配很大的对象
                            直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，则会触发JVM进行Full GC。

                            -》CMS垃圾收集器提供了一个可配置的参数，“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程
                -----------------------------------
                执行Minor GC的时候，JVM会检查老年代中最大连续可用空间是否大于了当前新生代所有对象的总大小。
                如果大于，则直接执行Minor GC（这个时候执行是没有风险的）。
                如果小于了，JVM会检查是否开启了空间分配担保机制，如果没有开启则直接改为执行Full GC。
                如果开启了，则JVM会检查老年代中最大连续可用空间是否大于了历次晋升到老年代中的平均大小，
                    如果小于则执行改为执行Full GC。
                    如果大于则会执行Minor GC，如果Minor GC执行失败则会执行Full GC

        分代收集算法:
            根据对象存活周期的不同将内存划分为几块(一般为新生代和老生代),根据不同代的特点采取不同的收集算法。
            新生代采用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。
            老年代采用标记清理算法/标记整理算法。对象存活率高且没有额外空间对它进行分配担保。

- OutOfMemoryError
    内存溢出：
        申请内存空间时，超出最大堆内存空间
    内存泄漏：
        内存空间没有及时释放，长时间导致占用内存，最终导致内存溢出
        出现情况：static/volatile 不能定太多常量

- 垃圾收集器
    串行与并行收集器：
        串行回收(单线程，不常用): JDK1.5前的默认算法 缺点:只有一个线程，执行垃圾回收时程序停止时间较长
        并行回收(多线程): 多个线程执行垃圾回收适合于【吞吐量】的系统，回收时系统【会停止运行】

    serial收集器：
        【串行收集器】是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
        新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）

        一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。
        特点：CPU利用率最高，停顿时间即用户等待时间比较长。
        适用场景：小型应用

        默认是串行，通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

    ParNew收集器：
        ParNew收集器其实就是Serial收集器的多线程版本。

        新生代并行，老年代串行；新生代复制算法、老年代标记-压缩
        参数控制：-XX:+UseParNewGC  ParNew收集器
        -XX:ParallelGCThreads 限制线程数量

    parallel收集器：
        Parallel Scavenge收集器类似ParNew收集器，Parallel收集器【更关注系统的吞吐量】
        可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；
        也可以通过参数控制GC的时间不大于多少毫秒或者比例；
        新生代复制算法、老年代标记-压缩

        采用【多线程来通过扫描并压缩堆】
        特点：停顿时间短，回收效率高，对吞吐量要求高。
        适用场景：大型应用，科学计算，大规模数据采集等。
        通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

    cms收集器：
        CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
        目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
        从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，

        整个过程分为4个步骤，包括：
            初始标记（CMS initial mark）
            并发标记（CMS concurrent mark）
            重新标记（CMS remark）
            并发清除（CMS concurrent sweep）
        其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。

        初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，
        并发标记阶段就是进行GC Roots Tracing的过程，
        而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

        由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，
        所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

        优点:响应时间优先，并发收集、低停顿
        缺点：产生大量空间碎片、并发阶段会降低吞吐量
        适应场景：大型服务器等。
        通过JVM参数 -XX:+UseConcMarkSweepGC设置

    g1收集器：
        在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。
        特点：支持很大的堆，高吞吐量
          --支持多CPU和垃圾回收线程
          --在主线程暂停的情况下，使用并行收集
          --在主线程运行的情况下，使用并发收集
        实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
        通过JVM参数 -XX:+UseG1GC 使用G1垃圾回收器

    OOM错误，stackoverflow错误，permgen space错误


- 类加载器(ClassLoader
    - 类加载器的层次结构：
        启动类加载器（使用C++语言实现（HotSpot虚拟机中），是虚拟机自身的一部分
            启动（Bootstrap）类加载器
        所有其他的类加载器（Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。
            标准扩展（Extension）类加载器
            应用程序（Application）类加载器
        自定义的类加载器

    层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，
    而这种父子关系一般通过组合（Composition）关系来实现，而不是通过继承
    - 双亲委派模式：
            某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，
            如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
      好处:
        防止内存中出现多份同样的字节码
      系统实现：
        java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，
        若没有加载则调用父类加载器的loadClass()方法，
        若父加载器为空则默认使用启动类加载器作为父加载器。
        如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

      打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法
      重写loadClass方法，将需要特殊对待的类自己先处理，非处理范围的类调用super方法即可。
      （SPI打破双亲委派机制案例）

    Java类初始化和实例化
        Java实例化方式：
            （1）用new 语句创建对象，这是最常用的创建对象方法。
            （2）运用反射手段，调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。
            （3）调用对象的clone()方法
            （4）运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。
        实例化顺序：
            1、JVM 的方法区中区寻找类的class对象，如果能找到，则按照定义生成对象，找不到则转2
            2、加载类定义：类加载器（classLoader）寻找该类的 .class文件，
               找到后对文件进行分析转换为class对象存入方法区方便以后调用。
               其中jdk 的class一般是在jvm启动时用启动类加载器完成加载，用户的class则是在用到的时候再加载。
            3、在jvm的堆中给对象开辟一个内存空间
            4、对象初始化
               初始化顺序：
                如果没有继承关系 初始化顺序为：
                    静态代码、静态代码块 >
                    成员变量、实例代码块 >
                    构造函数
                如果有继承关系（先父后子）初始化顺序：
                    父类static静态变量 > 父类static代码块 >
                        子类static静态变量 > 子类static代码块 >
                    父类变量 > 父类实例代码块 > 父类构造函数 >
                        子类变量 > 子类实例代码块 > 子类构造函数


热部署：
    1、最根本的方式是修改虚拟机的源代码，改变classloader的加载行为，
       使虚拟机能监听class文件的更新，重新加载 class 文件，
       这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。

    2、友好的方法是创建自己的classloader 来加载需要监听的class，
       这样就能控制类加载的时机，从而实现热部署





















