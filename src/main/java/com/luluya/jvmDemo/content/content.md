#jvm#
- Java内存结构
    HotSpotVM：(目前使用范围最广的Java虚拟机)
    运行时数据区域：
        线程共享
            [Java堆]：使用new的对象、定义数组(垃圾回收机制算法 jvm参数调优 内存溢出和内存泄漏)
                java虚拟机所管理的内存中最大的一块
                唯一目的就是【存放对象实例】，所有的对象实例以及数组都要在堆上分配
                垃圾收集器管理的主要区域，因此也被称为“GC堆”
                从内存回收角度来看，java堆可分为新生代和老生代
                从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区
                根据Java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中
                如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常

            [方法区]：类的信息、常量、静态变量(永久区 full GC)
                用于存储【已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据】
                别命叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常

                [运行时常量池]：
                    Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，
                    用于【存放编译期生成的各种字面量和符号引用】，这部分内容将在加载后进入方法区的运行时常量池中存放

        线程私有
            [Java虚拟机栈]：基本数据类型、局部变量(每个线程独立栈)
                生命周期和线程相同，Java方法执行的内存模型
                每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储：【局部变量表、操作数栈、动态链接、方法出口等信息】

                局部变量表
                    存放了【编译期可知的各种基本数据类型(8个基本数据类型)、对象引用(地址指针)、returnAddress类型】
                    所需的内存空间在编译期间完成分配。在运行期间不会改变局部变量表的大小
                    两种异常状态：
                        如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常
                        如果虚拟机栈可以动态扩展，在扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常

            [本地方法栈]：Java语言调用外部语言(C语言)方法使用native(CAS)
                本地方法栈与虚拟机栈所发挥作用非常相似，区别是虚拟机栈为虚拟机执行Java方法(即字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务。本地方法栈也是抛出两个异常

            [程序计数器]：
                程序计数器是一块较小的内存空间，是【当前线程所执行的字节码的行号指示器】
                由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令

                为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存
                程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域

        [直接内存]：
            不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。
            这部分区域被频繁使用，可能导致OutOfMemoryError异常
            NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，
            可使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作

    执行引擎：
        虚拟机核心的组件就是执行引擎，它负责执行虚拟机的字节码，一般户先进行编译成机器码后执行

- 垃圾回收机制
    不定时去堆内存中清理不可达对象。不可达的对象并不会马上就会直接回收。
    垃圾收集器在一个Java程序中的执行是自动的，不能强制执行。可通过调用System.gc方法来"建议"执行垃圾收集器，但其是否可以执行，什么时候执行却都是不可知的。

    finalize方法作用：
        在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。
        是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。
        在Object类中定义的(所有的类都继承了它)子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。
        finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。

    新生代与老年代:
        堆被划分成两个不同的区域：新生代(Young)、老年代(Old)。新生代(Young)又被划分为三个区域：Eden、From Survivor、To Survivor。
        划分目的：使JVM能够更好的管理堆内存中的对象，包括内存的分配以及回收。
        * 根据垃圾回收机制的不同，Java堆有可能拥有不同的结构

        新生代：存放新生的对象或者年龄不大的对象 age<15 ；老年代：存放老年对象。
        绝大多数情况下，对象首先分配在eden区，在新生代回收后，如果对象还存活，则进入s0或s1区，
        之后每经过一次新生代回收，如果对象存活则它的年龄就加1，对象达到一定的年龄后，则进入老年代。

    如何判断对象是否存活:
        引用计数法:(不选择使用
            给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加１；当引用失效时，计数器值减１.
            任何时刻计数器值为０的对象就是不可能再被使用的。
            为什么主流的Java虚拟机里面都没有选用这种算法呢？原因是它很难解决对象之间相互循环引用的问题。

        根搜索算法:
            通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，
            当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

            如何选取GCRoots对象：
                (1)虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
                (2)方法区中的类静态属性引用的对象。
                (3)方法区中常量引用的对象。
                (4)本地方法栈中JNI(Native方法)引用的对象。

    垃圾回收机制策略:
        标记清除算法:（老年代）
            该算法有两个阶段:
                1.标记阶段：找到所有可访问的对象，做个标记
                2.清除阶段：遍历堆，把未被标记的对象回收
            应用场景:
                应用于老年代,因为老年代的对象生命周期比较长
            优缺点:
                1. 优点
                    可以解决循环引用的问题
                    必要时才回收(内存不足时)
                2. 缺点：
                    回收时，应用需要挂起，也就是stop the world。
                    标记和清除的效率不高，尤其是要扫描的对象比较多的时候
                    会造成内存碎片(会导致明明有内存空间,但是由于不连续,申请稍微大一些的对象无法做到)

        复制算法:(新生代，去碎片化)
            如果jvm使用了coping算法，一开始就会将可用内存分为两块from域和to域，每次只是使用from域，to域则空闲着。
            当from域内存不够了，开始执行GC操作，这个时候，会把from域存活的对象拷贝到to域,然后直接把from域进行内存清理。

            1.当Eden区满的时候,会触发第一次young gc,把还活着的对象拷贝到Survivor From区；
              当Eden区再次触发young gc的时候,会扫描Eden区和From区域,对两个区域进行垃圾回收,
              经过这次回收后还存活的对象,则直接复制到To区域,并将Eden和From区域清空。
            2.当后续Eden又发生young gc的时候,会对Eden和To区域进行垃圾回收,存活的对象复制到From区域,并将Eden和To区域清空。
            3.可见部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代

            注意: 万一存活对象数量比较多，那么To域的内存可能不够存放，这个时候会借助老年代的空间。

            应用场景:
                使用在新生代中,因为新生代中的对象一般都是朝生夕死的,存活对象的数量并不多,coping算法进行拷贝时效率比较高。
            优缺点:
                优点:在存活对象不多的情况下，性能高，能解决内存碎片和java垃圾回收算法之-标记清除 中导致的引用更新问题。
                缺点:1.会造成一部分的内存浪费。不过可以根据实际情况，将内存块大小比例适当调整；2.如果存活对象的数量比较大，coping的性能会变得很差。

        标记整理算法:(老年代，去碎片化)
            标记清除算法和标记压缩算法非常相同，但是标记压缩算法在标记清除算法之上解决内存碎片化

            * 将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存

            任意顺序:不考虑原先对象的排列顺序，也不考虑对象之间的引用关系，随意移动对象
            线性顺序:考虑对象的引用关系，例如a对象引用了b对象，则尽可能将a和b移动到一块
            滑动顺序:按照对象原来在堆中的顺序滑动到堆的一端

            优缺点:
                优点:解决内存碎片问题
                缺点:压缩阶段，由于移动了可用对象，需要去更新引用

            MinorGC和FullGC区别:
                (新生代GC)MinorGC：
                    Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。
                (老年代GC)MajorGC/FullGC：
                    出现了MajorGC经常会伴随至少一次的MinorGC
                    (但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程)
                MajorGC的速度一般会比MinorGC慢10倍以上。
                -----------------------------------
                MinorGC触发机制：
                    当年轻代(Eden代)满时就会触发MinorGC，Survivor满不会引发GC
                FullGC触发机制：
                    当年老代满时会引发FullGC，FullGC将会同时回收年轻代、年老代，
                    当永久代满时也会引发FullGC，会导致Class、Method元信息的卸载其中
                    (JVM的永久代中会发生垃圾回收么？
                        垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。

        分代收集算法:
            根据对象存活周期的不同将内存划分为几块(一般为新生代和老生代),根据不同代的特点采取不同的收集算法。
            新生代采用复制算法。只需要付出少量存活对象的复制成本就可以完成收集。
            老年代采用标记清理算法/标记整理算法。对象存活率高且没有额外空间对它进行分配担保。

- JVM参数配置
    常见参数配置：
        GC参数
        -XX:+PrintGC        每次触发GC的时候打印相关日志
        -XX:+UseSerialGC    串行回收(不常用)
        -XX:+PrintGCDetails 打印详细的GC日志

        堆内存大小配置
        * 堆初始值 = 堆最大可用值
        -Xms                * 堆初始值
        -Xmx                * 堆最大可用值

        新生代堆参数配置
        -Xmn                * 新生代堆最大可用值
        -XX:SurvivorRatio   用来设置新生代中eden空间和from/to空间的比例.

        新生代与老年代占比
        -XX:NewRatio        * 配置新生代与老年代占比1:2(新生代空间比老年代小)
            含以-XX:SurvivorRatio=eden/from=den/to
            总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等，
            好处:减少程序运行时垃圾回收次数，提高效率。

- OutOfMemoryError
    内存溢出：
        申请内存空间时，超出最大堆内存空间
    内存泄漏：
        内存空间没有及时释放，长时间导致占用内存，最终导致内存溢出
        出现情况：static/volatile 不能定太多常量

- 垃圾收集器
    串行与并行收集器：
        串行回收(单线程，不常用): JDK1.5前的默认算法 缺点:只有一个线程，执行垃圾回收时程序停止时间较长
        并行回收(多线程): 多个线程执行垃圾回收适合于【吞吐量】的系统，回收时系统【会停止运行】

    serial收集器：
        【串行收集器】是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
        新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）

        一个单线程的收集器，在进行垃圾收集时候，必须暂停其他所有的工作线程直到它收集结束。
        特点：CPU利用率最高，停顿时间即用户等待时间比较长。
        适用场景：小型应用

        默认是串行，通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

    ParNew收集器：
        ParNew收集器其实就是Serial收集器的多线程版本。

        新生代并行，老年代串行；新生代复制算法、老年代标记-压缩
        参数控制：-XX:+UseParNewGC  ParNew收集器
        -XX:ParallelGCThreads 限制线程数量

    parallel收集器：
        Parallel Scavenge收集器类似ParNew收集器，Parallel收集器【更关注系统的吞吐量】
        可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；
        也可以通过参数控制GC的时间不大于多少毫秒或者比例；
        新生代复制算法、老年代标记-压缩

        采用【多线程来通过扫描并压缩堆】
        特点：停顿时间短，回收效率高，对吞吐量要求高。
        适用场景：大型应用，科学计算，大规模数据采集等。
        通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

    cms收集器：
        CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
        目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
        从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，

        整个过程分为4个步骤，包括：
            初始标记（CMS initial mark）
            并发标记（CMS concurrent mark）
            重新标记（CMS remark）
            并发清除（CMS concurrent sweep）
        其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。

        初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，
        而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

        由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，
        所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）

        优点:并发收集、低停顿
        缺点：产生大量空间碎片、并发阶段会降低吞吐量

        采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。
        （1）初始标记
        （2）并发标记
        （3）并发预处理
        （4）重新标记
        （5）并发清除
        （6）并发重置
        特点：响应时间优先，减少垃圾收集停顿时间
        适应场景：大型服务器等。
        通过JVM参数 -XX:+UseConcMarkSweepGC设置

    g1收集器：
        在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。
        特点：支持很大的堆，高吞吐量
          --支持多CPU和垃圾回收线程
          --在主线程暂停的情况下，使用并行收集
          --在主线程运行的情况下，使用并发收集
        实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
        通过JVM参数 -XX:+UseG1GC 使用G1垃圾回收器
        注意: 并发是指一个处理器同时处理多个任务。 
        并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 
        并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 
        来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。 

- 字节码技术
    应用场景：AOP技术、Lombok去除重复代码插件、动态修改class文件等
    优势：
        Java字节码增强指的是在Java字节码生成之后，对其进行修改，增强其功能，这种方式相当于对应用程序的二进制文件进行修改。
        Java字节码增强主要是为了减少冗余代码，提高性能等。

        实现字节码增强的主要步骤为：
        1、修改字节码
           在内存中获取到原来的字节码，然后通过一些工具（如ASM，Javaasist）来修改它的byte[]数组，得到一个新的byte数组。
        2、使修改后的字节码生效
           有两种方法：
           1）自定义ClassLoader来加载修改后的字节码；
           2）替换掉原来的字节码：在JVM加载用户的Class时，拦截，返回修改后的字节码；或者在运行时，使用Instrumentation.redefineClasses方法来替换掉原来的字节码

        javassist：
            是一个开源的分析，编辑和创建Java字节码的类库。性能较ASM差，跟cglib差不多，但是使用简单。很多开源框架都在使用它。
            优势：
                – 比反射开销小，性能高。
                –javassist性能高于反射，低于ASM
                运行时操作字节码可以让我们实现如下功能：
                – 动态生成 新的类
                – 动态改变某个类的结构 ( 添加 / 删除 / 修改    新的属性 / 方法 )
                javassist 的最外层的 API 和 JAVA 的反射包中的 API 颇为 类似 。
                它 主要 由 CtClass ， CtMethod, ，以及 CtField 几个类组成。用以执行和 JDK 反射 API 中 java.lang.Class， java.lang.reflect.Method， java.lang.reflect.Method .Field 相同的 操作 。
                方法操作
                – 修改已有方法的方法体（插入代码到已有方法体）
                – 新增方法   删除方法
            局限性：
                JDK5.0 新语法不支持(包括泛型、枚举)，不支持注解修改，但可以通过底层的 javassist 类来解决，具体参考:javassist.bytecode.annotation
                不支持数组的初始化，如 String[]{"1","2"} ，除非只有数组的容量为 1
                不支持内部类和匿名类
                不支持 continue 和 break表达式。
                对于继承关系，有些不支持。例如
                class A {}  
                class B extends A {} 
                class C extends B {} 

- 类加载器
    类加载的机制的层次结构：

    类加载器的层次结构

    理解双亲委派模式

    类加载器常用方法

    热部署






















